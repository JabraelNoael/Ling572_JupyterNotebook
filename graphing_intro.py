# -*- coding: utf-8 -*-
"""Untitled1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/17T7epwiNbC-Qf7iSDgzOFyEz31UI_u6n
"""

curve(dbeta(x,7,3),from=0,to=1,ylab="f(x)", main="Beta(7,3) density")

# set a seed for random number generation
set.seed(132471024)

p90<-c()  ## create a vector to store the 90th percentile from each sample
nsamples<-10000  ## set the number of simulations/samples to draw
for(i in 1:nsamples)  ## loop
{
  mysample<-rbeta(50,7,3)  ## draw 50 values from the beta(7,3) distribution
  p90[i]<-quantile(mysample,.9)  ## find the 90th percentile and store it in the vector
}
plot(density(p90)) ## A density curve is a smoothed histogram
mean(p90)

mean(p90>.88)

N <- 100 # population size

n <- 10 # sample size

# simulate population - draws N values from a standard normal distribution

population <- rnorm(N)

# true variance of population

sigmasq_true <- sum((population - mean(population))^2) / N

# bias term (we multiply by the reciprocal of this to correct bias)

bias <- ((n-1)/n) * (N/(N-1))

# sample population over and over

# calculate sigmasq estimate each time

# start by setting up storage vectors

sigmasq_hat <- c()
ssq<- c()
sigmasq_hat_unbiased <- c()

for (i in 1:5000) {

  # sample data (the sample command samples without replacement by default)
  samp <- sample(population, n)

  # calculate sample mean
  xbar <- mean(samp)

  # sample variance  (we could also compute this with the command var)
  ssq[i]<-sum((samp - xbar)^2) / (n-1)

  # biased sigma
  sigmasq_hat[i] <- sum((samp - xbar)^2) / n

  # unbiased sigma
  sigmasq_hat_unbiased[i] <-sum((samp - xbar)^2)/(n-1) * (N-1)/N

}

# true sigma

print(paste("True value:", round(sigmasq_true, 3)))

# biased estimate

print(paste("Biased estimate:", round(mean(sigmasq_hat), 3)))

# sample variace
print(paste("s-squared estimate:", round(mean(ssq), 3)))

# correct bias

print(paste("Unbiased estimate", round(mean(sigmasq_hat) * (1/bias), 3)))

plot(density(sigmasq_hat),col=3, main="Estimates of sigma_sq")
lines(density(sigmasq_hat_unbiased),col=2)
lines(density(ssq),col=4)
abline(v=sigmasq_true)

# sample size
n <- 25

# true mean
mu <- 35

# true standard deviation and variance
sigma2 <- 100
sigma <- sqrt(sigma2)

samples<- matrix(nrow=n, ncol=10000,data=rnorm(n=n*10000, mean = mu, sd = sigma))

xbars<-apply(samples, 2, mean)

# distribution of xbars

hist(xbars, main = paste("Average of sample means:", round(mean(xbars), 2)))

plot(density(xbars),main="Sampling Distribution of xbar")

curve(dnorm(x,mean=mu, sd=sigma/sqrt(n)),add=T,col=3)

# calculate proportion of times xbar is less than 30

round(mean(xbars < 30), 3)

pnorm((30-35)/(10/5),0,1)

## This is an estimate of a p-value

sds=apply(samples, 2, sd)
qt(.975,24) ## Compute the t* critical value to go in the margin of error for 95 percent confidence
lowers=xbars-2.064*sds/sqrt(n)
uppers=xbars+2.064*sds/sqrt(n)

missed <- lowers>mu | uppers<mu ## indicator of whether interval missed mu

mean(missed) ## Fraction of intervals that missed mu. Should be near .05 since we made 95% CIs mean(1-missed)

## Plot the CIs to show their coverage of mu

options(repr.plot.width=10, repr.plot.height=15)

plot(NA, xlim = range(lowers, uppers), ylim = c(0, 100))
abline(v = 35, lty = 2, lwd = 2)

for (i in 1:100)
{
  if (missed[i]) { arrows(lowers[i], i, uppers[i], i, angle = 0, col = "red") }
  else { arrows(lowers[i], i, uppers[i], i, angle = 0) }

}

###Noael's Code
##1a

z_values <- (xbars - mu) / (sigma / sqrt(n))
plot(density(z_values), main = "Question 1a", xlab = "Z", col = "blue")
curve(dnorm(x, 0, 1), add = TRUE, col = "red", lwd = 2)
legend("topright", legend = c("z-values", "Theoretical"), col = c("blue", "red"), lty = 1)
##1b

t_values <- (xbars - mu) / (sds / sqrt(n))
plot(density(t_values), main = "Question 1b", xlab = "T", col = "blue")
curve(dt(x, df=n-1), add = TRUE, col = "red", lwd = 2)
legend("topright", legend = c("t-values", "Theoretical"), col = c("blue", "red"), lty = 1)
##1c

plot(density(z_values), main = "Question 1c", xlab = "Value", col = "blue", ylim = c(0, max(density(z_values)$y, density(t_values)$y)))
lines(density(t_values), col = "red")
legend("topright", legend = c("Z-distribution", "T-distribution"), col = c("blue", "red"), lty = 1)
##1d

chi_values <- (n - 1) * (sds^2) / sigma2
plot(density(chi_values), main = "Question 1d", xlab = "Chi-squared", col = "blue")
curve(dchisq(x, df = n - 1), add = TRUE, col = "red", lwd = 2)
legend("topright", legend = c("chi-vlaues", "Theoretical"), col = c("blue", "red"), lty = 1)
sd_s2 <- sd(chi_values)
cat("Standard deviation of the sampling distribution: ", round(sd_s2, 3), "\n")
##2

t_critical_90 <- qt(0.95, df = n - 1)
lowers_90 <- xbars - t_critical_90 * sds / sqrt(n)
uppers_90 <- xbars + t_critical_90 * sds / sqrt(n)
missed_90 <- lowers_90 > mu | uppers_90 < mu
prop_missed_90 <- mean(missed_90)
cat("Question 2", round(prop_missed_90, 3))
options(repr.plot.width = 10, repr.plot.height = 15)
plot(NA, xlim = range(lowers_90, uppers_90), ylim = c(0, 100), xlab = "Confidence Interval", ylab = "Sample", main = "90% Confidence Intervals")
abline(v = mu, lty = 2, lwd = 2, col = "blue")
for (i in 1:100) {
  if (missed_90[i]) {
    arrows(lowers_90[i], i, uppers_90[i], i, angle = 0, col = "red")
  } else {
    arrows(lowers_90[i], i, uppers_90[i], i, angle = 0)
  }
}
###Noael's Code (End)