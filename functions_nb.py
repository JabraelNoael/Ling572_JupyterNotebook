# -*- coding: utf-8 -*-
"""functions_nb.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/github/gawron/python-for-social-science/blob/master/intro/functions_nb_2024.ipynb

# Functions, types, loops

Prerequisites:  In this notebook we assume you've been introduced to loop constructions
andf function definitions in Python by reading the text.

We'll begin with a brief review of ideas from the last module **python types**
that are most relevant to this notebook.

## Review of container-accessing operations

### Exercise 1

Add a line of code that will generate the give output::

     In [ ]: a_list = [2,7,8, 19]
             Your code
     Out [ ]: 2
     
NOTE: The idea of this kind of exercise is to write a line of code
that will produce the given output, 2 in this case.  Your
answer goes in the next cell, which is a code cell.  It should this be an
expression that operates on `a_list`.  A simple correct answer is:

     In [ ]: a_list = [2,7,8, 19]
             a_list[0]
     Out [ ]: 2
     
Don't forget to evaluate the cell after you've written in your answer to generate Python's output and check your answer!
"""

a_list = [2,7,8, 19]

print(a_list[0])

"""### Exercise 2

Write a line of code that produces the given output::
   
    In [ ]: a_list = ['sid','nancy','paul','ringo']
             YOUR CODE HERE
    Out [ ]: 'paul'
"""

a_list = ['sid','nancy','paul','ringo']

print(a_list[2])

"""### Exercise 3

Write a line of code that produces the given output:
   
     In [ ]: a_list = ['sid','nancy','paul','ringo']
           YOUR CODE HERE
     Out [ ]: ['nancy','paul']
"""

a_list = ['sid','nancy','paul','ringo']
#Write your answer below this
print(a_list[1:3])

"""## Loops

### Exercise 4:  Mapping title case

Write a line of code that produces the given output:

```
In [ ]: a_list = ['sid','nancy','paul','ringo']
        YOUR CODE HERE
Out [ ]: ['Sid','Nancy','Paul','Ringo']
```

Here are some hints.  It's easy to capitalize a string.
"""

'sid'.title(), 'the rain in spain falls mainly on the plain'.title()

"""But `.title()` is a method on strings, and it won't work on lists."""

a_list = ['sid','nancy','paul','ringo']
for x in a_list:
  print(x.title())

"""Notice that this makes **sense** if we think about the job a method is supposed to do.

Strings are the sort of thing you can add title case to.
Lists on the other hand may have arbitary elements, so defining a title case operatioon might be **possible**
(we'd have to check if it was a list of **strings**), but it doesn't make sense to define title-casing as a general
property of lists.

So do we do if we do have a list of strings and we want to add title to each string.
Well the string method
`.title()` will do exactly what we want if it is applied to each element in the list.  So
we need a **loop** that will apply `.title()` to each element in the list and collect the results.

If you're not using a list comprehension as your loop, try an answer with this format.  Insert a `for`-loop where it says "#Your code below here"
"""

a_list = ['sid','nancy','paul','ringo']
new_list = []
for x in a_list:
  new_list.append(x.title())
new_list

"""If you are using a list comprehension, your answer will have this format."""

a_list = ['sid','nancy','paul','ringo']
#Your list comprehension code below here inside the square brackets
new_list = [...   for x in ...]
new_list















"""`For`-loop solution:"""

a_list = ['sid','nancy','paul','ringo']
new_list = []
# Your code below here
for x in a_list:
    new_list.append(x.title())
new_list

"""List-comprehension solution."""

new_list = [x.title() for x in a_list]
new_list

"""Note: For long time Python users, `map` is also possible"""

list(map(str.title, a_list))

"""### Exercise 5:  Reversing sequences

Write a line of code that produces the given output:

```
In [ ]: a_list = ['sid','nancy','paul','ringo']
        YOUR CODE HERE
Out [ ]: ['Ringo', 'Paul', 'Nancy', 'Sid']
```
    
Hint: Try combining a list comprehension with a list reversal
"""

a_list = ['sid','nancy','paul','ringo']
Y = a_list.reverse()
print(a_list)
print(Y)

"""The `.reverse()` method returns `None`.

This is because it updates (destructively modifies) `a_list`, so its
effects are observed by inspecting `a_list`.  What it actually returns
is of no interest and the convention in Python is that when a value
is of no interest (irrelevant), it is `None`.

Now there is a way to produce a new list that is the reverse of
`a_list`, a way that leaves `a_list` unchanged.  That is to
use a slice with a step value of -1.

Illustrating step values, and especially negative step values
"""

print('abcdefghi'[::2])
print('abcdefghi'[2:8:2])
print('abcdefghi'[::-1])

print(a_list)
print(a_list[::2])
print(a_list[2:5:2])
print(a_list[::-1])

Y = a_list[::-1]
print(a_list)
print(Y)

"""Strings do not have a `.reverse()` method.  But reversal can still be
accomplished through a splice that has a `-1` step-size.  Since
splicing works the same for all sequences, this has the appeal of generality: It works for lists, tuples, and strings.
"""

X = 'abcdefghijklmnopqrstuvwxyz'
X[::-1]

a_list = ['sid','nancy','paul','ringo']
new_list = []
for letter in a_list[::-1]:
    new_list.append(letter.title())
new_list

"""## Boolean tests"""

print(X == 5)

"""#### Exercise 6:  Conditional branches

Write a line of code that will return True when applied to X.  There are of course many good answers:

    In [ ]: X = 'ringo'
            YOUR CODE GOES HERE
    Out [ ]: True

Write a line of code that will return False when applied to X:

    In [ ]: X = 'ringo'
            YOUR CODE GOES HERE
    Out [ ]: False
"""

X == 'ringo' #for true
X == 'not ringo' #for false

"""### Exercise 7: Conditional branches continued

Write an `if` statement (4 lines of code) that will print "Branch 1" for the first value of X; and "branch2" for the second value of X::
    
X = 'ringo'

YOUR IF-ELSE STATEMENT GOES HERE IT SHOULD PRINT `"Branch 1"`

X = 'paul'

COPY & PASTE THE SAME IF-ELSE STATEMENT HERE  IT SHOULD PRINT `"Branch 2"`
    
Hence the output from executing the cell above is just the two things that were printed

    Out [ ]: Branch 1
             Branch 2
             
Note there's more than one way to get this right.  Bear that in mind when you get to the next problem,
which will use the code you've written in this section.

It may be that you'll have to re think how you did this problem when you get to the next one.
"""

X = 'ringo'
if X == 'ringo':
    print('It says \'ringo\' (Branch 1)')
else:
    print('No \'ringo\' detected in string (Brach 2)')
X = 'paul'
if X == 'ringo':
    print('It says \'ringo\' (Branch 1)')
else:
    print('No \'ringo\' detected in string (Branch 2)')

"""In the previous cell you wrote some code.  In this cell you package it into a function definition.

Write a **function** called `find_branch` that prints `Branch 1` when applied to `ringo` and `Branch 2` when applied to `paul`.  For any other input it should print nothing.  To get this behavior, you may be able to use the same conditional you used above, or you may have to modify it.

Create a new cell and **test** your function in the new cell.
"""

#Your function definition goes here.
#Find Branch fn: this function returns branch 1 if it's ringo and 2 if it's paul
X='ringo'
def find_branch (Y):
  if Y == 'ringo':
    return '1'
  if Y == 'paul':
    return '2'
  else:
    return 'N/A'
print('Branch '+find_branch(X))

# Here are your tests.  The desired output is shown below this cell.
print('Example 1')
print('Branch '+find_branch('paul')+'\n')
print('Example 2')
print('Branch '+find_branch('ringo')+'\n')
print('Example 3')
print('Branch '+find_branch('Paul')+'\n')
print('Example 4')
print('Branch '+find_branch('ring')+'\n')

"""You should get the following output:

```
Example 1
Branch 2

Example 2
Branch 1

Example 3

Example 4
```

### Exercise 8:  Mapping Boolean tests

Write a line of code that produces the given output:
   
     In [ ]: a_list = ['john','paul','nancy','sid']
           YOUR CODE HERE
     Out [ ]: [True, True, False, False]
"""

a_list = ['john','paul','nancy','sid']
new_list = []
for x in a_list:
  if x == 'john' or x == 'paul' or x == 'ringo' or x == 'george':
    new_list.append(True)
  else:
    new_list.append(False)
    pass
new_list

"""The loop above can also be translated into a list
comprehension that simply collect s the results of whatever Boolean test you used.

Try to code that up in the next cell.
"""

## Your list comprension below this line inside the square brackets
a_list = ['sid','nancy','paul','ringo']
new_list = [ ]
new_list























# Your list comprehension code below, inside the square brackets
a_list = ['sid','nancy','paul','ringo']
new_list =  []
new_list

"""###  Exercise 9:  Filtering a list

Write a `for` loop that collects all the numbers in `test_list`
that are between 3 and 6 inclusive and places them
in a list named `result`.

In the cell below you are given a list  to work on and an initial value for the list `result`,
which you can update in a `for` loop.  The cell also evaluates `result` after the
loop to check that the value is right:

    In [ ]: test_list = [2, 7, 9, 4, 8, 3, 2, 6, 3, 5, 9, 18, 0, 5]
            result = []
            YOUR CODE GOES HERE
            result
     Out [ ]: [4,3,6,3,5,5]
                         
For updating the `result` list one element at a time the following may be of help.  The way to add `x` onto
the end of a list `result` is:

```
    result.append(x)
```

Note:  Instead of updating the list `result` one element at a time in
a `for-`loop, you can also do this with a list comprehension.
"""

test_list = [2, 7, 9, 4, 8, 3, 2, 6, 3, 5, 9, 18, 0, 5]
result = []
for x in test_list:
    ## Your filtering code goes here replacing pass
    pass
result



















test_list = [2, 7, 9, 4, 8, 3, 2, 6, 3, 5, 9, 18, 0, 5]
result = []
for x in test_list:
    ## Your filtering code goes here replacing pass
    if 3 <= x <= 6:
      result.append(x)
result



"""This can also be done with a list comprehension.  Note that this is the first list comprehension whose result is shorter than the list we are looping through.   This is because of where we put the condition.  Values are collected only for the x's that meet the condition."""

[x for x in test_list if 3 <= x <= 6]

"""### Exercise 10:  Counting

Now, using the same definition of `test_list`
as in exercise 6, write a `for` loop that **counts**
the number of integers in `test_list` that are between 3 and 6 inclusive
and  places the result in a variable named `tweeners`.
You can do this by just taking the length
of the list you computed in exercise 6, but try to do
it without building that list.  Just start with `tweeners`
set to 0 and increment its value by one each time you see an appropriate number.  
The value of the variable `tweeners` after the loop is exited should be 6.

Note the assignment statement that updates the value of `tweeners` by 1 is :

```
tweeners = tweeners + 1
```

or the slightly shorter but equivalent

```
tweeners += 1
```
"""

test_list = [2, 7, 9, 4, 8, 3, 2, 6, 3, 5, 9, 18, 0, 5]

tweeners = 0
# Your loop here, it's been started for
for num in test_list:
   # you update tweeners when appropriate here. Your code replaces pass
   pass

tweeners















len(test_list)

test_list = [2, 7, 9, 4, 8, 3, 2, 6, 3, 5, 9, 18, 0, 5]

tweeners = 0
# Your loop here, it's been started for
for num in test_list:
   # you update tweeners when appropriate here. Your code replaces pass
   if 3 <= num <= 6:
       tweeners += 1

tweeners

"""There is no list comprehension analogue to this loop because we're not collecting values in a list. Notice the following is a Syntax error"""

[ctr += 1 for num in test_list if  3 <= num <= 6]

"""Let's name the parts of a list comprehension

```
[collected for loop-var in iterable if filter]
```

The syntax error is raised because `collected` has to be an official Python expression, something with a value that can be included in the list being constructed.

```
ctr += 1
```

is an assignment to the variable `ctr`  so it is a statement.

### Exercise 11

Now, write a loop that computes the frequencies of the letters in `"abracadabra"`.  The frequencies should be
kept in a dictionary that has letters as keys and integers as values. After the counting code is executed,
the dictionary should look like this:

```
{'a': 5, 'b': 2, 'r': 2, 'c': 1, 'd': 1}
```
Do not use the `Counter` class from the Python `collections` module to solve this problem, even
though though that makes it easier.  The goal here is to get you writing loops.

Hint One:  Your  answer will use a loop and will contain this line (or something
equivalent) to update the dictionary count.

```
counter_dict[letter] = counter_dict[letter] + 1
```

Near synonym

```
counter_dict[letter] +=  1
```

The problem is that the dictionary needs to start out empty; the expression on the right hand
hand side of the `=` will raise a `KeyError` on an an empty dictionary, so this can't be what
you always do.

Inside the loop, you need to structure your code something like this:

```
    if [Boolean test to see if letter is a key in the dictionary]:
       # # the usual counting code
       counter_dict[letter] = counter_dict[letter] + 1
    else:
       # Start letter off with count 1
       counter_dict[letter] = 1
```

**Only read Hint Two in the next cell if you're stuck after trying hint One.**

Hint two:

Note: the test to see if `counter_dict` already contains `letter` as a key is:

```
letter in counter_dict
```
"""

test_str = 'abracadabra'

# Start with an empty dictionary
counter_dict = dict()

for letter in test_str:
    # Your code here (will be more than one line if you follow the hints)
    pass
counter_dict



























test_str = 'abracadabra'

counter_dict = dict()

for letter in test_str:
    if letter in counter_dict:
       counter_dict[letter] = counter_dict[letter] + 1
    else:
       counter_dict[letter] = 1
counter_dict









"""### Exercise 12

Filter  any items which occur
less than 2 times in a sequence of items.
Using `seq` as the name of the input sequence, your code should return the filtered version of `seq` and it should be of the same type as `seq`.

Below we will generalize the idea to allow sequence to be a
string, or tuple, or list.  For now we will handle the special case of a string.  You can use the following string as an example:

```
   seq = 'abracadabra'
```
Hint: Solve this problem in two parts.  First get all the needed counts and place them in a dictionary
using the code from the previous exercise. (Or you can if you like use a `Counter`, in which case
it will be helpful to review our discussion of Counters in [the book draft section on dictionaries](http://gawron.sdsu.edu/python_for_ss/course_core/book_draft/Python_introduction/dictionaries.html#python-collections-module).

Either way, you can then use counter dictionary you computed  to filter the letters in `"abracadabra"` with counts below 2.
"""

from collections import Counter
seq = 'abracadabra'
# Your code here

"""The issue. After filtering out the low-count elements in a list comprension, we need to turn the list into a string.  This won't work.  

Hint:  Use `.join()`.
"""

str(list('abracadabra'))





















seq = 'abracadabra'
elems = [elem for elem in seq if counter_dict[elem] >= 2]
''.join(elems)

"""Next generalize the idea to any sequence type(list tuple, or string).  Assume `counter_dict` has already been created.  Call the filtered sequence you create
`filtered`; the first step is to create a list of
filtered elements. Let's call that `elems`.  The trick is to ensure
"""

#seq="abracadabra"
#seq = tuple("abracadabra")
seq = list("abracadabra")
seq_type = type(seq)
elems = [x for x in seq if counter_dict[x] >= 2]
## The code that ensure elems is of the right type
## goes here.
filtered

str(elems)











#seq="abracadabra"
#seq = tuple("abracadabra")
seq = list("abracadabra")
seq_type = type(seq)
elems = [x for x in seq if counter_dict[x] >= 2]
if seq_type == str:
  filtered = ''.join(elems)
else:
  filtered = seq_type(elems)
filtered

"""### Exercise 13  Writing a simple retrieval function.

Write a function that returns the first element of any sequence.  Consider the function
to work as advertised if it raises an `Exception` if given a `dictionary` or a `set`.  These are not sequences.  Here are some examples of how it should work:

```
>>> first('william')
'w'
>>> first(['X', [0,1], ('a','b')])
'X'
>>> Z = first(['X', [0,1], ('a','b')])
>>> Z
'X'
```

Hint:  If you're having trouble getting this behavior, maybe you forgot
about `return`?.

Hint two:

The cell below starts your function definition for you.

```
def first(seq):
    # Your code here
```

The indented code that goes under `#Your code here`
shoukd perform a retrieval operation that uses the name `seq`.
"""

def first(seq):
  # Your code here replacing pass
  pass

"""Test your code by executing the next cell."""

print(first('william'))
Z = first(['X', [0,1], ('a','b')])
Z

Z = first(['X', [0,1], ('a','b')])
Z

print(Z)













def first(seq):
  return seq[0]

"""Note the following answer is **wrong**."""

def bad_first(seq):
  print(seq[0])

"""This can be seen using one of our tests."""

Z = bad_first(['X', [0,1], ('a','b')])
Z == 'X'

"""You were asked to write a function that returns the first element of a sequence
and this test checks to see that you did by setting a variable
to the value of executing the function.
In fact, this version of `first` doesn't return anything  (technically it returns `None`).

The first issue is that this function lacks a `return`
statement, so when the value of executing the function is used it will always be `None`,
the special Python object that generally stands for "no value of interest".

You might think the following edit fixes the problem.
"""

def first(seq):
  return print(seq[0])

Z = first(['X', [0,1], ('a','b')])
Z == 'X'

"""But it doesn't.  Why not?

While `print` is a function, it doesnt return what it prints. It returns nothing, technically `None`
again.

What `print` does is print something (by default, to standard output, which is why `X` appears
in the output above), and then it returns `None`.
"""

Z = first(['X', [0,1], ('a','b')])
Z == None

"""So be sure to be clear on the fact that returning a value and printing a value are two different things.
In fact, nothing in the problem statement asked for you to print a value and so your solution
should not include a call to the `print` function.

>Write a function that returns the first element of any sequence.  Consider the function
to work as advertised if it raises an `Exception` of givem a `dictionary` or a `set`.  

If you are asked to write a function that prints something, the directions
will specifically say that.

### Exercise 13:  Warning messages and returning a value in a corner case

Your most likely solution to the previous problem behaves like this:

```
>>> Z = first('')
IndexError                                Traceback (most recent call last)
...
IndexError: string index out of range
>>> Z
---------------------------------------------------------------------------
NameError                                 Traceback (most recent call last)
<ipython-input-3-b4379bcb7951> in <module>
----> 1 Z

NameError: name 'Z' is not defined

```
The call to `first` on an empty sequence raises an `IndexError` and the variable
`Z` never gets assigned a value, so attempting to use it causes a
`NameError`.  This is standard.  Any exception raised during execution interrupts
execution so the function never returns, not even with the value `None`),
so no value gets assigned to `Z` and `Z`  behaves like any i=unknown name (`NameError`).

Fix your function so that it behaves likes this (you will have to write the
`print` command issuing the warning yourself)

```
>>> Z = first('')
***Warning***: Empty sequence passed to first!
>>> Z == None
True
''
```

Note:  Your fixed function should continue to return the first element of a sequence
whenever possible:

```
In[0]: Z = first(['X', [0,1], ('a','b')])
        Z == 'X'
Out[0]:  True
```
"""

## Put code here















#soln 1
def first(seq):
  if len(seq) == 0:
    print("***Warning***: Empty sequence passed to first!")
    # This return prevents the next return statement from raising an exception.
    return
  return seq[0]

## soln 2
def first2(seq):
  if len(seq) == 0:
    print("***Warning***: Empty sequence passed to first!")
  else:
    return seq[0]

# soln 3  Use python Exception handling construction try/except:.
# Python principle:  It is better to ask forgiveness than to ask permission
def first3 (seq):
    try:
        return seq[0]
    except IndexError:
        print("***Warning***: Empty sequence passed to first!")

Z = first('')
Z == None

Z = first3('')
Z == None

"""### Exercise 14:  A palindrome function, reversing sequences

Write a function that creates a palindrome from any sequence, mutable
or immutable.  Here is how it should  work:

```
    In [ ]: x = palindrome('abcd')
    Out [ ]:
    In [ ] x
    'abcddcba'
```

Hint:  You can reverse any sequence `Seq` (mutable or immutable) with `Seq[::-1]`.
"""

# Your code here
#'abcd'[::-1]

def palindrome(W):
    # Yoru code here replacing pass
    pass

x = palindrome('abcd')
x























def palindrome(Seq):
    return Seq + Seq[::-1]

palindrome('abcd')

"""### Exercise 15: Using an optional argument

Modify the palindrome function of Exercise 11 so that it has an optional middle string which
is used as the center of the palindrome. Here are examples of how it should behave:

```
# Same as before, but we are checking for the optionality of the new arg
In [ ]: palindrome('ohno')     
Out [ ]: 'ohnoonho'

In [ ]: palindrome('madam', 'i')
Out [ ]: 'madamimadam'

In [ ]: palindrome('mada', 'mim')     
Out [ ]: 'madamimadam'

In [ ]: palindrome(L0 ='mada', center ='mim')     
Out [ ]: 'madamimadam'

In [ ]: palindrome(center ='mim', L0 ='mada')     
Out [ ]: 'madamimadam'
```

Hint:  For help with optional arguments and default values (which is what you need to worry about here), see [VanderPlas Whirlwind Tour of Python, Chap 8.](https://github.com/jakevdp/WhirlwindTourOfPython/blob/master/Index.ipynb)

Hint:  this problem can be solved by writing the function
with a conditional branch (check to see
if `center` has been supplied and do one thing if it has,
and another if it hasn't), but you actually don't need a conditional
branch, if you use the right default value for `center`.

Optional bell & whistle:  Have `palindrome` check to see if the `center` argument is a palindrome.
If it isn't, turn it into a palindrome by calling `palindrome` on just the center argument.
For example:

```
In[0]: palindrome('abcde','fgh')
Out[0]: 'abcdefghhgfedcba'
```
"""

# Your code here

"""Test your function using the following test suite.

The desired outputs have been been given in the cell below.  In order not
to lose sight of those outputs when testing, you can use the cell following
for testing.
"""

print(palindrome('madam','i'))
print(palindrome('ohno'))
print(palindrome('madam', 'i'))
print(palindrome('mada', 'mim'))
print(palindrome(L0 ='mada', center ='mim'))
print(palindrome(center ='mim', L0 ='mada'))

arglist = [('madam','i'),
           ('ohno',),
           ('madam', 'i'),
           ('mada', 'mim'),
           dict(L0 ='mada', center ='mim'),
           dict(center ='mim', L0 ='mada') ]

for args in arglist:
    if isinstance(args,dict):
        print(f"{args}  {palindrome(**args)}")
    else:
        print(args, palindrome(*args))

















def palindrome (L0,center=''):
    if center != center[::-1]:
       center = palindrome(center)
    return L0 + center + L0[::-1]

print(palindrome('madam','i'))
print(palindrome('ohno'))
print(palindrome('madam', 'i'))
print(palindrome('mada', 'mim'))
print(palindrome(L0 ='mada', center ='mim'))
print(palindrome(center ='mim', L0 ='mada'))

palindrome('abcde','fgh')

"""Notice that this version of `palindrome`  appears to have a circular definition.  It includes
a call to `palindrome` inside of it.

This is called recursion and it is perfectly fine as long as the inner call
to `palindrome` is on a simpler case (the inner call needs to find
a palindrome for just  `center`, not both `L0` and `center`).

### Exercise 16: Computing with coordinated sequences

The problem here is to coordinate the information from two coordinated lists.  Suppose we have coordinated lists of books and authors such that `authors[4]` is the author of `books[4]` and in fact for any appropriate index `i`,  `authors[i]` is the author of `books[i]`.

We will write a function which, given an item located at position `i` in list A produces the corresponding item located at position `i` in list B.  There is a way of computing this which avoids writing a loop; and that is to compute
a dictionary.  Set that idea aside for now.  We'll look at it later.  For now assume you will
need to loop through one of the sequences, needing to keep track of where you are to retrieve
the approrpiate information at position `i` in the other sequence,.

There are two ways of doing this.  You should do **both**.

1.  Using Python's `enumerate` iterator to keep track of the current index, loop through `books` to find the `War and Peace`, then use the index of `War and Peace` to find
the corresponding author in `authors`.  Note: although you could do this with the `.index()` method on lists, the point here is to illustrate `enumerate`.  Here is how `enumerate` works:

```
>>> for x in 'abcdefg':
       print(x)
a
b
c
d
e
f
g

>>> for (i, x) in enumerate('abcdefg'):
        print(i, x)
0 a
1 b
2 c
3 d
4 e
5 f
6 g
# Keeps track of the index of the current value of loop var.
```

2. Zip the two lists together to make a list a of pairs, turn that into a dictionary, and look up the author of `War and Peace` in the new dictionary.  The cells following this one demonstrates how `zip` works.

For either solution, your function should work as follows::

```
>>> authors = ['William Faulkner', 'Charles Dickens', 'Leo Tolstoy', 'William Golding']
>>> books = ['The Sound and the Fury', 'Our Mutual Friend', 'War and Peace',
              'Lord of the Flies']
>>> find_related_item_soln_one('Leo Tolstoy', authors, books)
'War and Peace'
>>> find_related_item_soln_two('Leo Tolstoy', authors, books)
'War and Peace'
```

Example code to help with solution one:
"""

lets = 'abcdefg'
codes = '9870234'
# Loop through lets, print code corresponding to let
for (i, x) in enumerate(lets):
        print(x, codes[i])

"""Example code to help with solution two."""

# We start by defining two sequences with linked information
# The second contains the code numbers for the first.
lets = 'abcdefg'
codes = '9870234'
Z = zip(lets, codes)
##  Let's look at zip objects to help understand them
##  Not a part of the necessary code for the loop below.
#  Plain zip object: Not much to look at
print('Zip object', Z)
# Cast it into a list, to print it out
print('Zip object => list', list(Z))
# Make a fresh zip object to iterate through (each zip object, like a stream, can
# be iterated through only once)
Z = zip(lets, codes)
for (x,y) in Z:
    print(x,y)

"""**Put your two solutions in the two cells below!**"""

authors = ['William Faulkner', 'Charles Dickens', 'Leo Tolstoy', 'William Golding']
books = ['The Sound and the Fury', 'Our Mutual Friend', 'War and Peace', 'Lord of the Flies']
# Soln #1
def find_related_item_soln_one(item, seq1, seq2):
    #  your code here replacinf pass
    pass

# Soln #2
# Soln #1
def find_related_item_soln_two(item, seq1, seq2):
    #  your code here replacinf pass
    pass

















def find_related_item_soln_one(item, seq1, seq2):
    for (x,y) in zip(seq1,seq2):
        if x == item:
            return y

def find_related_item_soln_two(item, seq1, seq2):
    for (i,x) in enumerate(seq1):
        if x == item:
            return seq2[i]

find_related_item_soln_one('Leo Tolstoy', authors, books)

"""The dictionary solution:"""

def find_related_item_soln_three (item, seq1,seq2):
    dd = dict(zip(seq1,seq2))
    return dd[item]

find_related_item_soln_three('Leo Tolstoy', authors, books)

"""Discuss how these solutions behave differently.

### Exercise 17:  Indexing and double loops

The next cell defines a sequence called `dwarves`.

In the next square write a list comprehension that constructs a list of
all possible dwarf partnerships. In  partnerships,
order does not matter.  So `('Grumpy','Sneezy')` is
the same partnership as `('Sneezy','Grumpy')`.
There are 7 dwarves, so there are (7*6)/2 or 21 partnerships.

So you need a piece of code
which pairs every dwarf with every other dwarf
but does not duplicate partnerships.  The way to
do this is to pair every dwarf with every dwarf that
follows him in the sequence.  You pair
`Sneezy` with the 6 dwarves following in the
sequence, then pair `Doc` with 5 dwarves following him.

Assign your list of pairs the name `result`.

Your code should look either like this.

```
result = [(dwarf1, dwarf2)  for ... in ... ]
```

or like this

```
result = [(dwarves[i], dwarves[j]) for ... in ... ]
```

Your code will involve a double loop through `dwarves` If your code is correct, `result` will be a list of length 21.  

Hint: One way to do this is to use `enumerate` and a double loop. By keeping track of what the index of the current dwarf is; then you know what part of the sequence of dwarves you need to pair this one with.   Another way is to loop through position indices using `range(len(dwarves))`.

If you print out the length and contents of `result`, it should look like  something this:

```
>>> len(result)
21
>>> result
[('Sneezy', 'Doc'),
 ('Sneezy', 'Sleepy'),
 ('Sneezy', 'Happy'),
 ('Sneezy', 'Dopey'),
 ('Sneezy', 'Grumpy'),
 ('Sneezy', 'Bashful'),
 ('Doc', 'Sleepy'),
 ('Doc', 'Happy'),
 ('Doc', 'Dopey'),
 ('Doc', 'Grumpy'),
 ('Doc', 'Bashful'),
 ('Sleepy', 'Happy'),
 ('Sleepy', 'Dopey'),
 ('Sleepy', 'Grumpy'),
 ('Sleepy', 'Bashful'),
 ('Happy', 'Dopey'),
 ('Happy', 'Grumpy'),
 ('Happy', 'Bashful'),
 ('Dopey', 'Grumpy'),
 ('Dopey', 'Bashful'),
 ('Grumpy', 'Bashful')]
 ```
"""

dwarves = ('Sneezy', 'Doc', 'Sleepy','Happy','Dopey','Grumpy', 'Bashful')
## Your code here



















dwarves = ('Sneezy', 'Doc', 'Sleepy','Happy','Dopey','Grumpy', 'Bashful')
result = [(dw1,dw2) for (i,dw1) in enumerate(dwarves) for dw2 in dwarves[i+1:]]
print(len(result))
result

"""Another way of computing this is to do the following.  Thinkl about why this gets the right number
of partnerships.
"""

dwarves = ('Sneezy', 'Doc', 'Sleepy','Happy','Dopey','Grumpy', 'Bashful')
result = [(dw1,dw2) for dw1 in dwarves for dw2 in dwarves if dw1 < dw2]
len(result)

"""Which way is more efficient?

## Optional Sudoku problem: A small programming challenge

This problem is **optional**.  Nevertheless it is good idea to tackle this
problem at some time during the class.

One idea is to leave until after we have done the programming nitebook in class,
which includes some programs of intermediate difficulty.

Just execute the code cell below.  We need it for the discussion and exercises that follow.  This code is an extract from a larger program for solving Sudoku puzzles and was written by Peter Norvig (Google "Norvig Sudoku"), who currently works for  Google.
"""

def cross(A, B):
    "Cross product of elements in A and elements in B."
    return [a+b for a in A for b in B]


digits   = '123456789'
rows     = 'ABCDEFGHI'
cols     = digits
squares  = cross(rows, cols)
unitlist = ([cross(rows, c) for c in cols] +
            [cross(r, cols) for r in rows] +
            [cross(rs, cs) for rs in ('ABC','DEF','GHI') for cs in ('123','456','789')])

# Assign to each square s A set of sets of squares
units = dict((s, [u for u in unitlist if s in u])
             for s in squares)
## Assign to each square s a set of squares, namely those that cant have the same value as s.
peers = dict((s, set(sum(units[s],[]))-set([s]))
             for s in squares)

# Turn a puzzle string into a dictionary.
def grid_values(grid):
    "Convert grid into a dict of {square: char} with '0' or '.' for empties."
    chars = [c for c in grid if c in digits or c in '0.']
    assert len(chars) == 81
    return dict(list(zip(squares, chars)))

def simple_grid_values (grid):
    "Convert grid into a dict of {square: char} with no restriction on contents"
    assert len(grid) == 81
    return dict(list(zip(squares, grid)))

################ Display as 2-D grid ################

def display(values):
    "Display these values as a 2-D grid."
    for s in squares:
        if values[s] == '0':
            values[s] = '.'
    width = 1+max(len(values[s]) for s in squares)
    line = '+'.join(['-'*(width*3)]*3)
    for r in rows:
        print(''.join(values[r+c].center(width)+('|' if c in '36' else '')
                      for c in cols))
        if r in 'CF': print(line)
    print()


grid1  = '003020600900305001001806400008102900700000008006708200002609500800203009005010300'
grid1_soln = '483921657967345821251876493548132976729564138136798245372689514814253769695417382'
grid2  = '003020600900305001001806400008102900700000008006708200002689500800203009005010300'
# Some illegal grids.
grid3  = '003020600900305001001806400008102900700000008006708200002609500800203089005010300'
grid4  = '003020609900305001001806400008102900700000008006708200002609500800203009005010300'
grid5  = '003020600900305061001806400008102900700000008006708200002609500800203009005010300'
g5_peers = peers['G5']
sgv = simple_grid_values(squares)
for s in g5_peers:
    sgv[s] = '__'

"""First some preliminaries, introducing the idea of a sudoku puzzle, for those who've never tried one.  According to Norvig:

A Sudoku puzzle is a grid of 81 squares; the majority of enthusiasts label the columns 1-9, the rows A-I [as in the grid below].

The grid below introduces **names** for the 81 squares in a grid.
"""



display(simple_grid_values(squares))

"""Next have a look at the 81 members of the list `squares`, which is noithing but a flat list if the 81 square names.   We will think about the code (above)
that constructs it.
"""

squares

"""Let's take a step by step approach to understanding Norvig's code
for constructing this list.

The code above defines the row labels in a Sudoku puzzle  in a variable `rows`. Write a `for`-loop that prints out the row labels in a Sudoku puzzle, one to a line.
"""

#[your code here]













for r in rows:
    print(r)

"""The code above defines the columns labels in a Sudoku puzzle  in a variable `cols`. Write a `for`-loop that prints out the column labels in a Sudoku puzzle."""

#[your code here]















for c in cols:
    print(c)

"""Here is  a loop that pairs `A` with every row number"""

#Your code here























r = 'A'
[r + c for c in cols]

"""It's easy enough to embed the code above in a list comprehension to get a list
of the rows:
"""















[[r + c for c in cols] for r in cols]

"""But this isn't what we want in order to construct squares.  We want a list comprehension that returns a flat list of the 81 square names. Therfore, we want a list comprehension
that starts

```
[r + c for ....]
```

Try to think through how to produce a list
of squares. If you get stuck, you may want to try modifying the code
in the cell above that produces a list of rows. Or you may want to look back at Norvig's code to see how he produces the list `squares`.  In any case you will need a double loop.
Write one double loop that produces the list of squares without calling
a function to help.
"""





















"""Just remove the square brackets from the last example:"""

sqs2 = [r+c  for c in cols for r in rows]
sqs2

"""Notice this isn't == to `squares` as computed by Norvig in the code above."""

sqs2 == squares

"""But the length is the same:"""

len(sqs2)

"""And we defined the same set of squares!"""

set(sqs2) == set(squares)

"""Modify the code above so that `sqs2` is == to `squares`."""

















#old version:  sqs2 = [r+c  for c in cols for r in rows]
sqs2 = [r+c  for r in rows for c in cols]
sqs2 == squares

"""Now let's think about what a puzzle is.  Also according to Norvig

>A collection of nine squares (column, row, or box) is called a **unit** and the squares that share a unit the **peers**. A puzzle leaves some squares blank and fills others with digits, and the whole idea is: A puzzle is solved if the squares in each unit are filled with a permutation of the digits 1 to 9.

Thus in each unit of a solved puzzle, all the
digits must appear, and no duplications are allowed.
The next square shows `grid1` a puzzle for which we were given both the  partially filled grid and its unique solution.

"""

display(grid_values(grid1))
print('     ... => ...')
print()
display(grid_values(grid1_soln))

"""Let's illustrate the idea of a peer.  Every cell belongs to three units, its
row, its column, and its box.  The cells in those units are its peers.
"""

display(sgv)

"""The peers of any cell are the squares which cannot have the same value as the cell.  The peers of `G5` are shown above.  There are 20 distinct peers.  The cells in row 'G', the cells in column '5' and the cells in the same box
as 'G5'.

The `peers` dictionary has been defined so that the key is a square and the value is the set of the 20 peers of that square.
"""

print(peers['G5'])

"""Let's return to the sudoku puzzle grid we called `grid1`; `grid1` is a legal grid, as we can check visually by redisplaying it."""

display(grid_values(grid1))

"""Here are some more grids displayed."""

display(grid_values(grid3))

display(grid_values(grid4))

"""If you look carefully at `grid5` you will see it differs from `grid1` in an important way."""

display(grid_values(grid5))

"""The grid `grid5` is not a legal Sudoku grid.  Can you see the problem?    There are two cells in the same box with same value.

To make this easy to get at in code, we will represent the grid in a dictionary so we can easily look up the values of particular squares in `grid5`.

`grid5` is a string.

```
003020600900305061001806400008102900700000008006708200002609500800203009005010300
```
Norvig's code provides us with a function `grid_values` which turns that string into a dictionary; the dictionary will be a lot
more convenient to work with for this problem.

```
>>> grid_dict5 = grid_values(grid5)
```

We demonstrate in the next cell
"""

grid_dict5 = grid_values(grid5)  #. Change the string `grid5` into a dictionary
print(grid5)
print(grid_dict5)
print(grid_dict5['A7'])

"""So here are  the facts that make `grid5` illegal."""

print(peers['A7'])
print(f"B8 is a a peer of A7: {'B8' in peers['A7']}")
print(f"{grid_dict5['A7']=}   {grid_dict5['B8']=}"\
       f"   Equal? {grid_dict5['A7'] == grid_dict5['B8']}")

"""Now look at `grid2` and `grid3`.  Are they legal?

Your assignment is to write a function that will print out `Invalid` if the grid_dict that is
passed in as an argument is illegal and will print out `Valid` if the grid_dict is legal.  Your function, named `test`, should take a grid_dict (the dictionary representation of a grid) as an argument
and it  should work as follows:

```
def test(grid):
     Your code goes here

test(grid_values(grid1))
test(grid_values(grid2))
test(grid_values(grid3))
test(grid_values(grid4))
test(grid_values(grid5))
```

When you finish your code and execute the lines above, the following should print out:

```
   Valid!
   Valid!
   Invalid!
   Invalid!
   Invalid!
```

One thing to think about is what test you will use to find out that a square is valid/invalid. Another thing to think about is
where in your code the two distinct `print` statements will go. You can't print 'Valid!' when you've seen one valid square.  You have to wait until all the squares have been proven valid.  Does it work exactly the same for 'Invalid!'? You can't print 'Invalid!'  when you've only seen one invalid square?

**Warning One**. It follows from the definition of invalidity that for any grid if squares B8 and A7 have the same value, then the grid is invalid.  Yet the following bit of Python is not a test for invalidity:

```
'B8'  == 'A7'
```

Can you see why not?

We want:
"""

grid_dict5 = grid_values(grid5)
grid_dict5['B8']  == grid_dict5['A7']  #Dictionary rep provides easy lookup of grid values!

"""So we want in effect to check all the pairs of squares that aren't allowed to contain the same value.   How can we do that?

Well you've been givien a very convenient data structure in the code above.
It's called `unitlist`.  It is a list of lists.  Each inner list contains the squares in what Norvig calls a "unit", a row, or a column, or a box.


"""

print(len(unitlist))
print(unitlist[0])   # Row 1
print(unitlist[20])  # THe box in the Upper Righthand Corner

"""Now look at the squares corresponding unitlist[20] in `grid5`"""

grid_dict5 = grid_values(grid5)
display(grid_dict5)

"""So we see it's the `unitlist[20]` unit, the upper right corner box,
that makes this puzzle invalid.

So the path grows clearer.  Check each unit to see if any squares in that unit have duplicate values.

The basic sketch for the `test` function is:

1.  Word on a `grid_dict gd` (the dictionary representation of a sudoku puzzle)
2.  Look at all the units.  
3.  For each unit `u` check whether the squares in `u` have any duplicate values in `gd`.
4.  If you find a duplicate, print 'Invalid!' and return
5.  If you don't find any duplicates.  Print 'Valid!' and return.

Let's assemble code that implements some of
the recipe above.

***Problem A***

In the next square write an expression that finds all the values in the ***filled*** squares of `unitlist[20]` in grid5.  Your code will use `grid_dict5`, the dictionary representation of `grid5`, and `unitlist[20]`.
"""

grid_dict5 = grid_values(grid5)

#Do something with grid_dict5 and unitlist[20]

# Here's what should be returned by the cell above when you add your code















"""Failed solution"""

[grid_dict5[sq]  for sq in unitlist[20]]

"""does not exclude the squares with the value `'0'`.  Fix this."""





















#Equivalent: fillers= [grid_dict5[sq]  for sq in unitlist[20] if not(grid_dict5[sq] == '0')]
fillers= [grid_dict5[sq]  for sq in unitlist[20] if grid_dict5[sq] != '0']
fillers

"""***Problem B***

Next goal:  Write a piece of code that detects if there is a duplicate
in `fillers`.  There are, of course, but we'd like to write a piece of code that will check any container `fillers` to see if there are duplicate values in it.

There are many ways to do this, but here are some hints for finding one
way that uses only constructions you know.

1.  Loop through the list while maintaining a set (I mean use the Python type `set`!) containing things you've already seen (call it `seen`).  When you come upon an element that you've seen before, print "Duplicate!".
2.  When you come upon an element you haven't seen, add it to the `seen` set (do `seen.add(element)`).
"""



















"""Here's an implementation of the basic idea:"""

seen = set()
for val in fillers:
    if val in seen:
        # Duplicate! Do something!
        print("Duplicate!")
    else:
        seen.add(val)

"""Look at the value of `seen`."""

seen

"""It has the same elements as `fillers`, with the duplicates removed.

This is fine.  But the duplicates in this case are the
first two elements we look at. Once we've seen that thre is a duplicate,
we could print out "Duplicate!" and stop computing.

That could be done as in the following code using the Python
`break` statement.  We can check that the `break` statement
performed as advertised by looking at the value `seen` after we
exit the loop.

"""

seen = set()
for val in fillers:
    if val in seen:
        # Duplicate! Do something!
        print("Duplicate!")
        break
    else:
        seen.add(val)

seen

"""So we didn't continue looking at elements after we saw the second '6'.

Now this unit clearly belongs to an invalid puzzle because of the
duplicate '6'. So if we could write code that detects the fact that there was a duplicate in `fillers` we would have written the code to see if a unit is valid!

In fact, we could pretty much just copy and paste the code (and change
what's printed out to "Invalid!")

Low-hanging fruit:  Use `return` in place of `break`.  We are putting
this loop in a function definition. When we detect a duplicate
we can just `return` and stop executing the function, necause
we now know the puzzle is irredeemably invalid.

Less low-hanging fruit: If we exhaust all ways in which puzzle-invalidating duplicates could occur, and we have found no duplicates, we can print
`Valid!`.

***Problem C***

In the next square loop through all units in unitlist and for **each** unit, set the variable `fillers` to the values of the filled squares in the unit, and then print the unit (the 9 square names in the current unit) and the value of `fillers`.
"""













for unit in unitlist:
    print(unit)
    # Copying the code from above
    fillers= [grid_dict5[sq]  for sq in unit if grid_dict5[sq] != '0']
    print(fillers)
    print()

"""Now of course the code above does not belong in your `test` function.  Ther's no reason to be printing all this nonsense out.  But a modified version
of it does beloing in your `test`.

You now have all the ingredients to write your `test` function.  
Let's review the idea to verify that.


1.  Work on a `grid_dict gd` (the dictionary representation of a sudoku puzzle) ***Problem A showed us how to use the `grid_dict gd`***
2.  Look at all the units.  ***Problem C*** showed us how to loop throuigh all the units.***
3.  For each unit `u` check whether the squares in `u` have any duplicate values in `gd`. ***Problem B implemented duplicate checking.****
4.  If you find a duplicate, print 'Invalid!' and return.  ***Problem B did something very close to this.***
5.  If you don't find any duplicates.  Print 'Valid!' and return. This should now be clear.   After checking every unit, if no dupes are found, it's okay to print 'Valid!'.
"""

