# -*- coding: utf-8 -*-
"""Boolean_exercises_in_numpy (4).ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/13damEMzMqRfUK2HGbKmCSRGVE5CHOiiC

# Boolean operations, Boolean masks, and Boolean combinations

The purpose of this assignment is to give you more practice using Boolean constraints on `numpy` arrays.  but it is also to introduce one new wrinkle in applying Boolean constraints to arrays: Boolean combinations of constraints.

To start off, we load forest covertype data (Note: This will take a little while because it downloads a large dataset from the web). This is a multi class dataset that has data for 7 different forest covertypes (stored in the target attribute). There are 581,012 forest plots with 54 attributes each (stored in a 581012 x 54 array) The first ten attributes are numerical, the last 44 are Boolean (true/false) attributes. Each of the Boolean attributes represents a qualitative soil type attribute which is either present or absent. We will refer to all the attributes by their column index. Thus the first attribute is attribute 0 and the last (a Boolean attribute) is attribute 53.
"""

#from sklearn.datasets import load_wine
#wdata = load_wine()
from sklearn.datasets import fetch_covtype
data = fetch_covtype()
print(data.data.shape)  # data.data is the 581012 x 54 array
# data.target contains the covertype for each instance  This is what we're trying to predict
print(data.target.shape)

"""[The Boolean arrays and masks notebook](https://github.com/gawron/python-for-social-science/blob/master/numpy/02_06_Boolean_Arrays_and_Masks.ipynb) discusses combining Boolean arrays with Boolean operators `&` (conceptually 'and') and `|` (conceptually 'or') and  `~` (conceptually 'not').  Study the examples there, especially the examples used on the Seattle rainfall data.  Pay special attention to the use of parentheses, because using them correctly matters in solving the following problems.

Each of the following problems concerns finding a particular set of rows in the covertypes dataset. For each set do two things:

a. Construct a single Python expression which counts the number of rows in the set.
b. Construct a single Python expression which returns all the rows of the covertype dataset that are in the set.  (Note: not just the Boolean array, but the rows you get when use the Boolean array as a mask).

 1.  The rows in the covertype dataset which do not have either covertype 1 or covertype 2.
 2.  The rows which have attribute 10 (Note:  this is a qualitative wilderness area attribute).
 3.  The rows with elevation above 200.
 4.  The rows of covertype 1 or 2 with elevation above 200 which have attribute 10.
 5.  The rows neither of covertype 1 or 2 with elevation above 200 which have attribute 10.

The `sklearn` description of the covertype dataset is out below. For a fuller understanding of the attributes in the dataset you can look at [the original UCI data set description.](https://archive.ics.uci.edu/ml/datasets/Covertype) but that is not necessary to solve the problem.

The `data` object loaded above is a wrapper which contains three attributes.
"""

dir(data)

print(data.DESCR)

"""Example:  `data.data`  is a `numpy` array containing the attributes for the 581,012 samples.  

"""

print(type(data.data))
print(data.data.shape)

"""
To compute the Boolean array  that identifies the rows in which attribute 0 is greater than 3000 you do"""

WW = data.data[:,0] > 3000
print(WW)
print(WW.shape, data.data.shape)

WW.sum()

"""Note the Boolean array has the same number of rows as the entire dataset.  To find the rows that satisfy this condition, you use this Boolean array as a
**mask**. That is, you do:
"""

print(data.data[WW,:])
data.data[WW,:].shape

"""Note the new array contains just the rows that satisfies condition `WW` , so it is smaller.

The covertypes (or dominant tree) for each forest plot are in `data.target`.  The `target` attribute is often the attribute used to store the classes in an `sklearn` clasification dataset. There are seven classes.
"""

print(data.target.shape)
print(set(data.target))

"""Finally the fact that attribute 12 is qualitative means the only values in that column are 0 and 1.
Each plot either has or doesn't have attribute 12.
"""

set(data.data[:,12])

[bool(x) for x in set(data.data[:,12])]

"""#### Questions 1a and 1b

Place your answer to questions 1a and 1b in the next cell.  Scroll down to see a valid answer.
"""

# 1a
rowsNot1or2 = ((data.target != 1) & (data.target != 2)).sum()
print(rowsNot1or2)

# 1b
rowsNot1or2_b = data.data[((data.target != 1) & (data.target != 2))]
rowsNot1or2_b.shape

"""#### Questions 2a and 2b

Place your answer to questions 2a and 2b in the next cell.
"""

# 2a
rowsWithAttributes = (data.data[:, 10] == 1).sum()
print(rowsWithAttributes)

# 2b
rowsWithAttributes_b = data.data[data.data[:, 10] == 1, :]
rowsWithAttributes_b.shape

"""#### Alternative answer to 2a and 2b:

Recall that `BC2` is a Boolean condition, that is, an array consisting entirely of
Booleans (`True` or `False`).    You can also try an answer that uses
the `.astype(int)` method.

#### Questions 3a and 3b

Place your answer to questions 3a and 3b in the next cell.
"""

# 3a
rowsAbove200 = (data.data[:, 0] > 200).sum()
print(rowsAbove200)

# 3b
rowsAbove200_b = data.data[data.data[:, 0] > 200, :]
rowsAbove200_b.shape

"""#### Questions 4a and 4b
Place your answer to questions 4a and 4b in the next cell.
"""

# 4a
rows4 = (((data.target == 1) | (data.target == 2)) & (data.data[:, 0] > 200) & (data.data[:, 10] == 1)).sum()
print(rows4)

# 4b
rows4_b = data.data[((data.target == 1) | (data.target == 2)) & (data.data[:, 0] > 200) & (data.data[:, 10] == 1), :]
rows4_b.shape

"""#### Questions 5a and 5b

Place your answer to questions 5a and 5b in the next cell.
"""

# 5a
rows5 = (((data.target != 1) & (data.target != 2)) & (data.data[:, 0] > 200) & (data.data[:, 10] == 1)).sum()
print(rows5)

# 5b
rows5_b = data.data[((data.target != 1) & (data.target != 2)) & (data.data[:, 0] > 200) & (data.data[:, 10] == 1), :]
rows5_b.shape