# -*- coding: utf-8 -*-
"""Copy of numpy_exercises.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1uEnMbp7cTfDMBcnq65nPExkTN2ZBtwt0

# Numpy Exercises

In all the exercises, the term **vector** means a 1-dimensional `numpy` array.

One of the goals of these exercises is to give you a chance to practice what you know.  Another is to introduce you to some basic `numpy` tools. The exercises are liberally sprinkled with hints.  When the hint mentions a `numpy` function or method you've never heard of, you can use `np.info` (illustrated in the two cells below) to learn more.
"""

np.info(np.ones)

A = np.array([1,2])
np.info(A.sort)

"""## Exc 15

Create a 2-Dimensional array with 1s on the border and 0s inside.  Hint below if desired.
"""

import numpy as np
array_2d = np.ones((5, 5), dtype=int)
array_2d[1:-1, 1:-1] = 0
array_2d

"""Use a slice assignment.

## Exc 25

Given a 1D array, negate all elements which are between 3 and 8, in place.  Hint below if desired.
"""

import numpy as np
arr = np.array([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])
for i in range(len(arr)):
  if (arr[i] > 3) & (arr[i] < 8):
    arr[i] *= -1
arr

"""Hint: You can do this with a Boolean mask and a `*=` assignment.

## Exc 36

Extract the integer part of a random array of positive numbers.  Hint: Many ways.  `np.trunc`, `np.float`, `dtype=int`.  Here is a random array.
"""

import numpy as np
R = 100*np.random.sample(100)
R

"""## Exc 37

Exconomically create a 5x5 matrix in which each row is the following 1D array:

```python
np.array([0, 1,2,3,4])
```

Hint Use broadcasting.  Note there's more than one way to use broadcasting to get this done.
"""

import numpy as np
matrix = np.array([0, 1, 2, 3, 4])
result_matrix = np.tile(matrix, (5, 1))
result_matrix

"""## Exc 38 (Didn't fully get, revist late)

In this excercise you will construct a **generator function* that generates 10 integers and use it to build an array.

Use `np.fromiter` to construct a 5x2 array containing the first 10 Fibonacci numbers in order.
The argument to `np.fromiter` must be a generator.

Hint:  revisit the `Golden_ratio_exercise.ipynb` notebook and find the generator function
that generates Fibonacci numbers.  You might also want to review how to use it in the examples there,
or review generators in the `Iterators, Iterables, generators (with examples)` notebook.

"""

import numpy as np

def fibonacci_generator(n):
  a, b = 0, 1
  for _ in range(n):
    yield a
    a, b = b, a + b

fibonacci_array = np.fromiter(fibonacci_generator(10), dtype=int)
fibonacci_matrix = fibonacci_array.reshape(5, 2)
fibonacci_matrix

"""## Exc 39

Create a vector of size 10 with values ranging from 0 to 1, both excluded.  Use `np.linspace`.
"""

vector = np.linspace(0, 1, 12)[1:-1]
vector

"""## Exc 40

Consider two random arrays A and B, check if they are equal.

Hint: see Exc. 36 for the random array part. Remember: `==` does not return a Boolen in an array comparison.
"""

import numpy as np
R = 100*np.random.sample(100)
L = 100*np.random.sample(100)
if (R == L).all():
    print("Equal")
else:
    print("Not equal")

"""## Exc 43

Make an array immutable (read-only). Hint: `arr.flags.writeable`.
"""

import numpy as np

arr = np.array([1, 2, 3, 4, 5])
arr.flags.writeable = False

"""## Exc 44 (Unfinished, revist)

Consider a random 10x2 matrix representing cartesian coordinates, convert them to polar coordinates.  Hint.  `np.arctan2`, `np.linalg.norm`.   To be able to correctly handle
the tangents for tangents not in the first quadrant, we want `np.arctan2`,
which takes Y and X as separate arguments.  For example $(-\sqrt{3}/2,\, -.5)$
has a different $\theta$  than  $(\sqrt{3}/2,\, .5)$, but the slope, $y/x$,
is the same.

Here is a random 10x2 matrix
"""

-np.pi/3

"""Use `np.linalg.norm` and `np.arctan2`, but apply them in vectorized form:"""

import numpy as np
x1,y1 = .5, -np.sqrt(3)/2
vec1 =  np.array([x1,y1])
print(np.linalg.norm(vec1))
np.arctan2(y,x)

x2, y2 = np.sqrt(2)/2, np.sqrt(2)/2
x3, y3 = .6, .8
vec2 =  np.array([x2,y2])
vec3 =  np.array([x3,y3])
M = np.array([vec1,vec2,vec3])
M.shape

M

"""Apply np.linalg.norm so as to get the norm of each row:"""

np.linalg.norm(M)

np.linalg.norm(M,axis=0)

#A = np.random.random((10,2))
# Sample both positive and negative values x,y coords
A = np.array([2*(random.random() -.5) for _ in range (20)]).reshape(10,2)
A

"""## Exc 45

Create random vector of size 10 and replace the maximum value by 0.  Hint `R.argmax()`.

Here is a random vector.
"""

R =  np.random.sample((10))
R[R.argmax()] = 0
print(R)

"""## Exc 46

Create a structured array with x and y coordinates covering the [0,1]x[0,1] area . Hint: `np.meshgrid`.
"""

x = np.linspace(0, 1, 100)
y = np.linspace(0, 1, 100)
#xv,yv shape (100,100)
xv, yv = np.meshgrid(x, y)

"""Make a three D array of this so that the top layer is the x-coors and the the bottom layer is the
y-coords.

## Exc 89.

The 3 largest values of the array `R` defined in the next cell, computed as an array of size 3.    Hint `np.sort` or `np.argsort`. Call your answer array `ans89`.  Verify your answer by using a Boolean mask to determine how many elements of `R` are larger than or equal to the smallest element of `ans89`.
"""

R = 100*np.random.sample((100,))
R.sort()
ans89 = R[-3:]
ans89

"""Verifying:"""

mask = R >= ans89[0]
num_elements = np.sum(mask)
print(f"Number of elements in R larger than or equal to the smallest element of ans89: {num_elements}")

"""## Exc 50

How do you find the closest value (to a given scalar) in a vector?  In particular, find the closest value to 12 in the vector `R` defined below.  Write a function that does this for any `x` and any vector any vector `v`.

Hint: `np.abs` gives the absolute value.  It is vectorized.  Look up what a vectorized function is if you don't know this term.
"""

R = 100*np.random.sample((100,))
scalar = 12

import numpy as np

def find_closest_value(x, v):
  return v[np.abs(v - x).argmin()]

R = 100 * np.random.sample((100,))
scalar = 12

closest_value = find_closest_value(scalar, R)
print(f"The closest value to {scalar} in R is: {closest_value}")
print("\nSee for yourself")
R.sort()
print(R)

"""## Exc 55
What is the equivalent of enumerate for numpy arrays? Demonstrate usage in a loop.   Hint: `np.ndenumerate`.   Or use `np.ndindex`
"""

arr = np.array([[1, 2], [3, 4]])

for index, value in np.ndenumerate(arr):
  print(f"Index: {index}, Value: {value}")

"""## Exc 59 (Revisit: didn't fully grasp question/answer)

Sort an array by the  8th column. Hint below if desired.
"""

R = np.random.randint(0,100,100)
arr = np.random.randint(0, 100, size=(10, 10))
sorted_indices = np.argsort(arr[:, 7])
sorted_array = arr[sorted_indices]

sorted_array

"""Hint: `R.argsort()` followed by fancy indexing.

## Exc 64

Add 1 to each element of vector `v` that is indexed by a second vector `idxs` containing only valid indexes of `v`.  Do the update inplace.  That is, modify the vector `v`.  Allow `idxs` to contain  repeated indexes, but when an index repeats, don't add 1 twice.
"""

import random
v = np.array(random.sample(range(100),10))
I= random.choices(range(10),k=6)
while len(I) == len(np.unique(I)):
    I= random.choices(range(10),k=6)

I

"""Also note the following alternative.

## Exc 58

Subtract the mean of each row of the  matrix `R`.
"""

R = np.array(random.sample(range(100),90)).reshape((9,10))

row_means = np.mean(R, axis=1, keepdims=True)
R_centered = R - row_means
R_centered

"""# Part 2

In `numpy`, dtype=ubyte refers to the unsigned 8-bit integer data type.
Here's what you need to know:

$$
\begin{array}{ll}
\text{Unsigned} & \text{This means the integer can only represent positive values (and  0).}\\
\text{8-bit} & \text{This means the integer is stored using 8 bits (1 byte) of memory.}\\
\text{Range} & \text{The range of values that can be represented is from 0 to 255 (inclusive)}.\\
\end{array}
$$

Common uses:

1.  Image processing: Representing pixel values in grayscale images.
2.  Binary data: Storing data efficiently where only small positive integer values are needed.

Note `ubytes` don't look any different from ordinary integers.
"""

arr = np.array([10, 20, 30], dtype='ubyte')
print(arr)

"""1 byte per item; 1 bytes is 8 bits; $2^{8}$ is 256, so only 256 distinct integers can
be repsresented in a `ubyte`: 0-255.
"""

arr.itemsize

arr2 = np.array([10, 20, 30], dtype=int)
arr2

"""8 bytes per item.  That's 64 bits."""

arr2.itemsize

"""What is the theoretical maximum for a Python integer?"""

maxint = 2**64
print(f"{maxint-1:,}")

"""Except it clearly isn't.  Do you see the evidence?

The fact is that we got our size of 8 bytes by looking in a `numoy` array and `numpy` and Python implement integers differently. Python does something clever and there is no max int.  Or to put it more technically: There is no fixed maximum value. Python integers can grow as large as your system's memory allows.

The `numpy` implementation is different; 64-bit integers are actually implemented as `C long` integers.  So numbers in arrays have fixed memory allocations and arrays consume predictable amounts of memory.

Let's look at the array's datatype.
"""

arr2.dtype

"""So that suggests the `numpy` maxint value is $2^{64} - 1$, but there's a slight complication. We want to represent both positive and negative integers:"""

np.iinfo(np.int64)

"""So we need one bit for the sign, a binary piece of information.  Therefore the `numpy`
maxint value is:
"""

2**63  - 1

"""This is okay:"""

arr2[0] = 2**63 - 1

"""But going just one higher does indeed blow up the array:"""

arr2 = np.array([10, 20, 30], dtype=object)
arr2[0] = 2**63

"""What `numpy` is offer a menu of integer types:"""

np.iinfo(np.int32)

np.iinfo(np.int16)

np.iinfo(np.int8)

"""So for ordinary 8-bit integers, the max val is $2^{7} -1$.   Meanwhile back to our array of `ubyte` integers.  """

arr.dtype

"""This datatype is for positive integers only, so the maximum value is:"""

np.iinfo(np.uint8)

"""When the maximum value is exceeded:"""

arr[2] = 255

"""We got a stiffly worded warning not an error, together with the notification that this sort of behavior won't be tolerated in the future.

## Exc 66

Considering a (w,h,3) image of (dtype=ubyte), compute the number of unique colors.

Hint: Use `np.unique`.
"""

import random

w, h = 128, 128

sz = w*h*3
I = np.array(random.choices(range(256),k=sz),dtype='ubyte').reshape((w,h,3))
#  For a smaller example values from the range 0-3 inclusive.
#I = np.random.randint(0, 4, (h, w, 3)).astype(np.ubyte)

# An RGB value: One color
I[27,38]

unique_colors = np.unique(I.reshape(-1, 3), axis=0)
len(unique_colors)

"""A clunky but correct solution.  Turn color-triples into tuples, collect the set."""

NumColors = len({tuple(I[i,j]) for i in range(w) for j in range(h)})
print(f"There were {NumColors:,} distinct colors used in  {w*h:,} pixels"\
      f" from {256**3:,} possible color values.")

"""Try to do this more numpythonically (and faster!) using `np.unique()`

## Exc 71

Consider an array of dimension (5,5,3), how to multiply it by an array with dimensions (5,5)?   Hint.  Use the rules of broadcasting.
"""

a = np.arange(75).reshape((5,5,3))
b = np.arange(50,75).reshape((5,5))

a = np.arange(75).reshape((5,5,3))
b = np.arange(50,75).reshape((5,5))
a * b[:,:,None]

"""## Exc 72

Swap rows $i$ and $j$ of an array.  Swap rows 2 and 4 of the 6x4 array `M` in the cell below.  Hint:  It's fancy indexing time.
"""

i,j = 2, 4
r,c = 6, 4
M = np.arange(24).reshape((r, c))

M[[i, j]] = M[[j, i]]
M

"""**Without**:
array([[ 0,  1,  2,  3],
       [ 4,  5,  6,  7],
       [ 8,  9, 10, 11],
       [12, 13, 14, 15],
       [16, 17, 18, 19],
       [20, 21, 22, 23]])
**With**:
rray([[ 0,  1,  2,  3],
       [ 4,  5,  6,  7],
       [16, 17, 18, 19],
       [12, 13, 14, 15],
       [ 8,  9, 10, 11],
       [20, 21, 22, 23]])

## Exc 95.

Convert a vector of ints into a matrix binary representation.

i e

```python
[1,3,5]  ->  [[0,0,0,0,0,0,0,0,1],
              [0,0,0,0,0,0,0,1,1],
              [0,0,0,0,0,0,1,0,1]]
```

Hint:  Check out `np.unpackbits`.
"""

def int_to_binary_matrix(vector):
  max_val = np.max(vector)
  num_bits = int(np.ceil(np.log2(max_val + 1)))

  binary_matrix = []
  for num in vector:
    binary_representation = bin(num)[2:].zfill(num_bits)
    binary_row = [int(bit) for bit in binary_representation]
    binary_matrix.append(binary_row)

  return np.array(binary_matrix)

vector = [1, 3, 5]
int_to_binary_matrix(vector)

"""## Exc 90.

Write a function which, given an arbitrary sequence of vectors, returns the Cartesian Product (every combination of every item).

$$
s_{1} \times s_{2} \times \dots \times s_{n} =
\lbrace \langle\, x_{1},\, x_{2},\, \dots x_{n}\, \rangle \mid
x_{1} \in s_{1} \wedge x_{2} \in s_{2} \wedge \dots \wedge x_{n} \in s_{n} \rbrace
$$

There's a solution that doesn't use numpy arrays, or at least doesn't require `vs` to be a sequence of vectors,
It implements `cart_prod` as a recursive function.

Here is an example of how your function might behave:

```python
>>> L = cart_prod([[1,2,3],[4,5],[6,7]])
>>> print(len(L))
12
>>> L
[(1, 4, 6),
 (2, 4, 6),
 (3, 4, 6),
 (1, 5, 6),
 (2, 5, 6),
 (3, 5, 6),
 (1, 4, 7),
 (2, 4, 7),
 (3, 4, 7),
 (1, 5, 7),
 (2, 5, 7),
 (3, 5, 7)]
```

Note that what has been returned is a set of 3-tuples. That's because
the input was three vectors.  Had the input been 4 vectors, the value
returned would have been a sequence of 4-tuples.  Returning
a sequence of tuples is okay. For this input, your function can return any sequence of sequences
of length 3.  Note that means  it could also return a 12x3 array:

```python
array([[1, 4, 6],
       [2, 4, 6],
       [3, 4, 6],
       [1, 5, 6],
       [2, 5, 6],
       [3, 5, 6],
       [1, 4, 7],
       [2, 4, 7],
       [3, 4, 7],
       [1, 5, 7],
       [2, 5, 7],
       [3, 5, 7]])
```

This is the **preferred** output.  Stating this in one sentence: For an input that is a sequence of
$N$ vectors, the preferred output is an MxN array (in the example M=12), but your function can
return any sequence of M sequences of length N.

It is perfectly possible to solve this problem by writing a recursive function.
And if you think that's more than enough of a challenge stop reading here.

There is another more numpy-thonic solution that uses `np.indices`.   What follow
are some hints for how `np.indices` can help:

First let's sketch how `np.indices` is usually used:
"""

import numpy as np
#a = np.arange(20,dtype=int).reshape((4,5))
(R, C) = np.indices((4,5))

R

C

"""These are indices appropriate for accessing the rows (`R`) and columns (`C`)
of a 4x5 array, arranged in a shape that's approrpiate for the application of a numpy u-function.

What that means is that I can define another array `M` as a u-function of the these two index arrays.
For example:

$$
\text{M}\lbrack i,\,j\rbrack = i^{2} + j^{2}
$$
"""

M = R**2 + C**2
M

"""Now the usefulness of `np.indices` in doing Cartesian products arises from
the fact that it returns an array.  Watch what happens when you reshape it.
"""

M = np.indices((3,4))
M.reshape((2,-1)).T

"""These are the indices we could use in constructing the Cartesian Product
of two groups: a group of size 3 and a group of size 4.  The first column contains
indices appropriate for the group of size 3.  The second contains
indices appropriate the group of size 4.  Together the indices would index all possible
pairs which consist of one member from the first group and one from the second.
Hmm.

What's left for you to think about is how to use a sequence of indices to construct
a sequence of the corresponding group members; as well as how to generalize what you've been shown from the Cartesian product of two groups to the Cartesian product of an arbitrary number of groups.
"""

import numpy as np

def cart_prod(vs):
  dimensions = [len(v) for v in vs]
  indices = np.indices(dimensions)
  # Flatten indices to iterate through all combinations
  flat_indices = indices.reshape(len(dimensions), -1).T
  result = []
  for index_tuple in flat_indices:
    current_combination = [vs[j][index] for j, index in enumerate(index_tuple)]
    result.append(current_combination)

  return np.array(result)

cart_prod([[1, 2, 3], [4, 5], [6, 7]])

"""## Exc. 88  (Conway's Game of Life)

Implement Conway's Game of Life using `2D` numpy arrays.

Brief description adapted from the Wikipedia page:

We have an infinite grid of 0s and 1s and a ticking clock.
Each clock tick some of the 1s become 0s (they **die** in the language of the game),
some of the 0s become 1s (they **are born** in the language of the game)
And some of the cells remain the same (they **survive** or remain dead). At time `t=0` the grid
is given an initial configuration of 0s and 1s, and
the configurations for any later time `t=n+1` are given by the
following rules

1.  What happens to any cell at time `t=n+1` is determined by its 8 neighboring
    cells at time `t=n`. The 8 neighbors of any grid cell `x` are:
    
    ```
    n n n
    n x n
    n n n
    ```
    
2.  If x = 1  and fewer than 2 of its neighbors or more than 3 of its neighbors are 1,
    then x becomes 0 (x **dies**).
3.  If x = 1  and exactly 2 or exactly 3 of its neighbors are 1,
    then x stays 1 (x **survives**).
4.  If x = 0 and exactly 3 of its neighbors are 1, x becomes 1 (x **is born**).
    Otherwise, if x is 0, x stays 0.

Finally, you may be having some trouble with the idea of implementing an infinite grid.  No problem.  Make a 2D array any size you choose (say, M.shape = 50x50), and
just update the interior cells, leaving out the first and last rows
and the first and last columns.  You will need an initial array, which should be
random.  Here is the code for that, where `r` is the number of rows and `c` the number of
columns:

```python
I = np.random.randint(0,2,(r,c))
```

One way to go:

Hint:  A loop-based solution.  Write a function `decide` that takes the game grid and a position `i`, `j` as its argument. Using the rules above,
the function `decide` decides the fate of the cell
at position `i`, `j` in the next generation.  Then write another `next_gen` that takes the current game grid as its single argument; `next_gen`  loops through all the interior cells and applies `decide` to each  to produce the new game grid.  Note that the game grid should be a 2D array `I` and `next_gen` cannot  update `I` as it is looping through it, since that may change the survival status of cells it hasn't gotten to yet.  Therefore you need the new game grid  to be a new matrix of the same shape as `I`.

Another better way:

There is a solution that combines the two functions in the loop-based
solution.  Call it `next_gen2`; `next_gen2` correctly updates the current (nxn) game grid
without looping.  The idea is to construct a single (n-1)x(n-1) score grid  N (that contains the scores of all the interior
cells) by doing array addition.  `N[0,0]` contains the score for `I[1,1]`, where by score
I mean the number of living neighbors.  Then the survival rules can be applied
to `N`. And `I` can be updated with the results.

Because N just scores the interior
cells, N is (n-2) x (n-2) and `N[i,j]` contains the sum of the neighbors of `I[i+1,j+1]`:

$$
\begin{array}{lclll}
N[i,j] & = & I[i,j]\, + &  I[i+1,j] \,+ &  I[i+2,j] \,+\\
        &   & I[i,j+1]\, + &            & I[i+2,j+1] \,+\\
        &  & I[i,j+2] \,+ &  I[i+1,j+2] \,+ & I[i+2,j+2]\\
\end{array}
$$

A successful solution to the problem is a working version of `decide` and `next_gen`
or, for those who want a great exercise in array-based programming, a
working version of `next_gen2`.

Display: Not part of the stated problem, but fun.
You can display a generation by passing your updated numpy array
to `matplotlib.pyplot.imshow`.  Unfortunately it won't work to just put that in a loop to
**animate** a game.  What you can do is display
a predetermined number of states in a loop, producing a column of images, as shown below.
I would count that as a successful  solution of this problem.

If you find looking at a long column of images a little tedious,
and you want to truly animate a game, you need to learn about `matplotlib.animation`.
That's a useful visualization tool, and I will present an example of how to use it
in the solution, but be forewarned thar there are some peculiarities to deal with in getting the animation module to work in a notebook.

Here's an example of how to initialize a random grid (10x10) to be
your game state at `t=0`.
"""

import numpy as np
import random
r,c = (10,10)
L= range(2)
I = np.random.randint(0,2,(r,c))
I

"""Helpful comment, if youw ork on a 10x10 grid as illustrated above, don't forget  you're updating just the
interior 8x8 grid, omitting the first and last row and the first and last column.

Here's how to display a game state:
"""

from matplotlib import pyplot as plt

art = plt.imshow(I)

"""Here's how to display a sequence of game states in a loop (key point: you **need** the `plt.show()`
command, which not only displays the image but also resets `matplotlib` to be ready for the next
display).
"""

from matplotlib import pyplot as plt
import numpy as np
r,c = (10,10)
I = np.random.randint(0,2,(r,c))

for i in range(10):
    art = plt.imshow(I)
    plt.show()
    # np.roll is just a random way to change the image
    # of course your code will do something other than this to I.
    # np.roll slides the image one column to the left, while "rolling"
    # the first column around to become the last.
    I = np.roll(I,-1,axis=1)

import numpy as np

def next_gen2(I):
  rows, cols = I.shape
  new_I = I.copy()
  N = np.zeros((rows - 2, cols - 2), dtype=int)

  for i in range(rows - 2):
    for j in range(cols - 2):
      N[i, j] = (
          I[i : i + 3, j : j + 3].sum() - I[i + 1, j + 1]
      )
  for i in range(1, rows - 1):
    for j in range(1, cols - 1):
      if I[i, j] == 1:
        if N[i - 1, j - 1] < 2 or N[i - 1, j - 1] > 3:
          new_I[i, j] = 0
      else:
        if N[i - 1, j - 1] == 3:
          new_I[i, j] = 1
  return new_I

for _ in range(10):
  I = next_gen2(I)
  import matplotlib.pyplot as plt
  plt.imshow(I)
  plt.show()